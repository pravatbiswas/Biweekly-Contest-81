class Graph_struct:
   def __init__(self, V):
      self.V = V
      self.adj = [[] for i in range(V)]

   def DFS_Utililty(self, temp, v, visited):

      visited[v] = True

      temp.append(v)

      for i in self.adj[v]:
         if visited[i] == False:
            temp = self.DFS_Utililty(temp, i, visited)
      return temp

   def add_edge(self, v, w):
      self.adj[v].append(w)
      self.adj[w].append(v)

   def connected_components(self):
      visited = []
      conn_compnent = []
      for i in range(self.V):
         visited.append(False)
      for v in range(self.V):
         if visited[v] == False:
            temp = []
            conn_compnent.append(self.DFS_Utililty(temp, v, visited))
      return conn_compnent

class Solution:
    def countPairs(self, n: int, edges: List[List[int]]) -> int:
        my_instance = Graph_struct(n)
        for a, b in edges:
            my_instance.add_edge(a, b)
        conn_comp = my_instance.connected_components()
        if len(conn_comp) <= 1:
            return 0
        res = 0
        for i in range(len(conn_comp)):
            for j in range(i + 1, len(conn_comp)):
                res += len(conn_comp[i]) * len(conn_comp[j])
        return res
        
        
        
        
        
        
        
        
